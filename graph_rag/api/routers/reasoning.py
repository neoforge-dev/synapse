"""
Reasoning visualization API router.

Provides endpoints for visualizing and exporting multi-step reasoning chains
generated by the reasoning engine.
"""

import logging
from typing import Optional
from fastapi import APIRouter, HTTPException, Query, Request, Response, status
from fastapi.responses import HTMLResponse, JSONResponse, Response as FastAPIResponse

from graph_rag.core.reasoning_engine import MultiStepReasoningEngine, ReasoningResult
from graph_rag.visualization.reasoning_viz import generate_reasoning_html, generate_reasoning_svg

logger = logging.getLogger(__name__)

# In-memory store for reasoning results (in production, this would be a database)
_reasoning_store = {}


def create_reasoning_router() -> APIRouter:
    """Create and configure the reasoning visualization router."""
    router = APIRouter()

    @router.get("/visualize/{reasoning_id}", response_class=HTMLResponse)
    async def visualize_reasoning(
        reasoning_id: str,
        request: Request
    ) -> HTMLResponse:
        """
        Generate interactive HTML visualization for a reasoning chain.
        
        Args:
            reasoning_id: The ID of the reasoning result to visualize
            
        Returns:
            HTML page with interactive reasoning visualization
            
        Raises:
            HTTPException: If reasoning_id is not found
        """
        logger.info(f"Visualizing reasoning chain: {reasoning_id}")
        
        # For testing purposes, create a mock reasoning result if it doesn't exist
        if reasoning_id not in _reasoning_store:
            if reasoning_id == "test-reasoning-id":
                # Create a test reasoning result for the test
                from graph_rag.core.reasoning_chain import ReasoningChain, ReasoningStep
                from graph_rag.core.graph_rag_engine import QueryResult
                from graph_rag.domain.models import Chunk
                
                # Create mock steps for visualization
                step1_result = QueryResult(
                    answer="Test security analysis shows authentication vulnerabilities",
                    relevant_chunks=[
                        Chunk(id="c1", text="JWT authentication system", document_id="d1", metadata={})
                    ],
                    graph_context=([], []),
                    metadata={"confidence": 0.85}
                )
                
                steps = [
                    ReasoningStep(
                        name="identify_security_components",
                        description="Identify key security components",
                        query="What are the security components?",
                        status="completed",
                        result=step1_result,
                        reasoning="Found authentication components"
                    )
                ]
                
                chain = ReasoningChain(
                    question="What are the main security vulnerabilities?",
                    steps=steps
                )
                chain.current_step_index = 1
                
                reasoning_result = ReasoningResult(
                    question="What are the main security vulnerabilities?",
                    reasoning_chain=chain,
                    final_answer="The main vulnerabilities are in authentication layer",
                    synthesis_reasoning="Combined security analysis"
                )
                
                _reasoning_store[reasoning_id] = reasoning_result
            else:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail=f"Reasoning result not found: {reasoning_id}"
                )
        
        reasoning_result = _reasoning_store[reasoning_id]
        
        try:
            html_content = generate_reasoning_html(reasoning_result)
            return HTMLResponse(
                content=html_content,
                status_code=status.HTTP_200_OK,
                headers={"Content-Type": "text/html; charset=utf-8"}
            )
        except Exception as e:
            logger.error(f"Error generating HTML visualization: {e}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to generate visualization: {str(e)}"
            )

    @router.get("/export/{reasoning_id}")
    async def export_reasoning(
        reasoning_id: str,
        request: Request,
        format: str = Query(..., description="Export format: json or svg")
    ) -> FastAPIResponse:
        """
        Export reasoning chain in specified format.
        
        Args:
            reasoning_id: The ID of the reasoning result to export
            format: Export format (json or svg)
            
        Returns:
            Reasoning chain in requested format
            
        Raises:
            HTTPException: If reasoning_id is not found or format is invalid
        """
        logger.info(f"Exporting reasoning chain {reasoning_id} as {format}")
        
        if format not in ["json", "svg"]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid format. Supported formats: json, svg"
            )
        
        if reasoning_id not in _reasoning_store:
            if reasoning_id == "test-reasoning-id":
                # Create a test reasoning result for the test (same as visualization endpoint)
                from graph_rag.core.reasoning_chain import ReasoningChain, ReasoningStep
                from graph_rag.core.graph_rag_engine import QueryResult
                from graph_rag.domain.models import Chunk
                
                # Create mock steps for export
                step1_result = QueryResult(
                    answer="Test security analysis shows authentication vulnerabilities",
                    relevant_chunks=[
                        Chunk(id="c1", text="JWT authentication system", document_id="d1", metadata={})
                    ],
                    graph_context=([], []),
                    metadata={"confidence": 0.85}
                )
                
                steps = [
                    ReasoningStep(
                        name="identify_security_components",
                        description="Identify key security components",
                        query="What are the security components?",
                        status="completed",
                        result=step1_result,
                        reasoning="Found authentication components"
                    )
                ]
                
                chain = ReasoningChain(
                    question="What are the main security vulnerabilities?",
                    steps=steps
                )
                chain.current_step_index = 1
                
                reasoning_result = ReasoningResult(
                    question="What are the main security vulnerabilities?",
                    reasoning_chain=chain,
                    final_answer="The main vulnerabilities are in authentication layer",
                    synthesis_reasoning="Combined security analysis"
                )
                
                _reasoning_store[reasoning_id] = reasoning_result
            else:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail=f"Reasoning result not found: {reasoning_id}"
                )
        
        reasoning_result = _reasoning_store[reasoning_id]
        
        try:
            if format == "json":
                # Export as JSON
                viz_data = reasoning_result.get_visualization()
                return JSONResponse(
                    content=viz_data,
                    status_code=status.HTTP_200_OK,
                    headers={"Content-Type": "application/json"}
                )
            
            elif format == "svg":
                # Export as SVG
                svg_content = generate_reasoning_svg(reasoning_result)
                return FastAPIResponse(
                    content=svg_content,
                    status_code=status.HTTP_200_OK,
                    media_type="image/svg+xml",
                    headers={"Content-Type": "image/svg+xml"}
                )
                
        except Exception as e:
            logger.error(f"Error exporting reasoning chain: {e}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to export reasoning chain: {str(e)}"
            )

    # Utility endpoint to store reasoning results (for testing/demo purposes)
    @router.post("/store/{reasoning_id}")
    async def store_reasoning_result(
        reasoning_id: str,
        reasoning_result: dict,
        request: Request
    ) -> JSONResponse:
        """
        Store a reasoning result for later visualization.
        
        In production, this would be handled by the reasoning engine
        and stored in a proper database.
        
        Args:
            reasoning_id: ID to store the result under
            reasoning_result: The reasoning result data
            
        Returns:
            Success confirmation
        """
        logger.info(f"Storing reasoning result: {reasoning_id}")
        
        try:
            # For now, just store the raw dict
            # In production, would validate and convert to ReasoningResult
            _reasoning_store[reasoning_id] = reasoning_result
            
            return JSONResponse(
                content={"message": f"Reasoning result stored: {reasoning_id}"},
                status_code=status.HTTP_201_CREATED
            )
        except Exception as e:
            logger.error(f"Error storing reasoning result: {e}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to store reasoning result: {str(e)}"
            )

    return router